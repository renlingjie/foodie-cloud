前言：下面某个技术可能在多个地方用到，这里只整理最具代表性的，以便后续作为向导来复习
1、主要将项目拆分为User、Item、Order、Cart四个微服务。它们都会作为Eureka-Client注册到Eureka中
因此在每个Web的bootstrap.yml中都指定了注册中心的地址

2、Order的Api层有对User、Item通过Feign发起服务间的调用，同时使用Feign集成的Ribbon，且负载均衡策略为默认

3、Order的Web的application.yml设置了对User远程调用时的超时重试策略，以及Feign的全局默认参数

4、Order/User的Web的application-dev.yml设置了全局的远程调用时的降级熔断的超时触发策略、熔断半开策略、隔离方式

5、Hystrix单独使用：在User的PassportController的login方法中，通过@HystrixCommand指定了降级熔断的超时触发策略、熔断半开策略、
隔离方式。同时指定了降级方法，并编写了该指定的降级方法吃

6、Feign集成Hystrix使用：Order因为要实现对Item提供给它的Feign接口ItemCommentsService的降级，因此需要自己写降级方案，
在order/fallback/itemservice下自定义接口继承ItemCommentsService，编写继承接口ItemCommentsFeignService的降级实现类
ItemCommentsFallback，实现远程调用的降级

7、想通过Config-Server控制User注册功能的开关，因此User的bootstrap.yml中在Eureka配置之后，还要引入Config-Server的service-id，
当然可以引入ip，但是这里为Config-Server的高可用，做了基于Eureka的高可用，即使只有一个Config-Server，也还是用service-id
  之后User就可以连接上配置中心，在PassportController的register中，通过从Gitee拉取的某个属性，控制该功能的开关

8、TODO 配置中心改造需要：
(1)按照约定大于配置：
  I、我们的Gitee中需要在根目录下新建各个服务的"服务名"对应的文件夹，这样只需在Config-Server中search-paths: '{application}'
  即可在一个请求到Config-Server后，直接到该请求对应服务的"服务名"的文件夹下，拉取该服务的配置
  II、文件夹下的文件名也需要"服务名"-profile.yml或"服务名"-profile.properties命名，Client无需指定name(文件名，默认用
  "服务名"去作为文件名)，之后只需指定profile(dev or pro)、label(分支)即可
(2)Bus总线式的架构中心
  I、Config-Server、Client都引入bus-amqp、actuator依赖，且application的dev/pro配置文件中引入RabbitMQ的连接信息(TODO 节点XXX安装)
  II、Client用到"需要刷新的配置项"的类上加@RefreshScope注解
  III、之后通过actuator暴露的endpoints--bus-refresh，请求某个Config-Server或Client，即可全部刷新
(3)Config-Server高可用
  I、Config-Server的application.yml中引入注册中心地址，同时记得加Eureka的依赖、注解
(4)加密
  I、Config-Server的bootstrap.yml中设置密钥，发送请求到这里加密，之后将加密串写入Gitee中即可

  主要应用/改造点：User、Item、Order、Cart有各自的数据库，因此在各自的Gitee服务名文件夹下，配置加密后的password
